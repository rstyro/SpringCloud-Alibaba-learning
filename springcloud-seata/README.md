### 一、前言
+ 事务指的就是一个操作单元，在这个操作单元中的所有操作最终要保持一致的行为，要么所有操作
都成功，要么所有的操作都被撤销。简单地说，事务提供一种 “要么什么都不做，要么做全套” 的机制。

#### 1、本地事务
+ 本地事务其实可以认为是数据库提供的事务机制。
+ 说到数据库事务就不得不说，数据库事务中的**四大特性:ACID**
	+ **A：原子性(Atomicity)**，一个事务中的所有操作，要么全部完成，要么全部不完成
	+ **C：一致性(Consistency)**，在一个事务执行之前和执行之后数据库都必须处于一致性状态
	+ **I：隔离性(Isolation)**，在并发环境中，当不同的事务同时操作相同的数据时，事务之间互不影响
	+ **D：持久性(Durability)**，指的是只要事务成功结束，它对数据库所做的更新就必须永久的保存下来
+ 数据库事务在实现时会将一次事务涉及的所有操作全部纳入到一个不可分割的执行单元，
+ 该执行单元中的所有操作要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚

#### 2、分布式事务
+ 分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。
+ 简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，
+ 分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

#### 3、分布式理论
+ 在分布式事务中，事务的ACID原则难以满足，所以出现了解决分布式事务的理论方法，如下
+ 分布式系统的经典理论：CAP理论 与BASE理论

##### ①、CAP理论
+ CAP 定理（CAP theorem）又被称作布鲁尔定理（Brewer's theorem）。
+ 是加州大学伯克利分校的计算机科学家埃里克·布鲁尔（Eric Brewer）在2000年的`ACM PODC`上提出的一个猜想。
+ 2002年，麻省理工学院的赛斯·吉尔伯特（Seth Gilbert）和南希·林奇（Nancy Lynch）发表了布鲁尔猜想的证明，使之成为分布式计算领域公认的一个定理。
+ 是 `Consistency`、`Availablity`和`Partition-tolerance`的缩写。
	+ ***一致性（Consistency）：*** 即更新操作成功并返回客户端完成后， 所有节点在同一时间的数据完全一致，这里的一致性是指的强一致性，一般关系型数据库就有强一致性特性。。
	+ ***可用性（Availablity）：*** 即服务一直可用，而且是正常响应时间。
	+ ***分区容忍性（Partition-torlerance）：*** 在网络分区的情况下，被分隔的节点仍能正常对外服务


***CAP权衡：***

|选择|说明|
|--|--|
|CA|放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择。放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。|
|AP|放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此|
|CP|放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用|

***总结：***
+ CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性。
+ CAP理论告诉我们分布式系统只能选择`CP`或者`AP`,因为放弃P那就不是分布式系统了，所以一般都会根据业务在C和A之间寻求平衡。。

##### ②、BASE理论
+ eBay的架构师`Dan Pritchett`源于对大规模分布式系统的实践总结，在ACM上发表文章提出`BASE理论`，BASE理论是对CAP理论的延伸。
+ BASE是指基本可用（Basically Available）、软状态（Soft State）、最终一致性（ Eventual Consistency）
+ 核心思想是即使无法做到强一致性，但应用可以采用适合的方式达到最终一致性（Eventual Consitency）
+ 每一个应用都可以根据自身的业务特点，采用适当的方式达到最终一致性。

***基本可用(Basically Available)***
+ 基本可用指分布式系统在出现不可预知的故障时候，允许损失部分可用性，保证核心服务可用。
+ 比如电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务熔断限流

***软状态（Soft State）***
+ 简单的说就是不同节点的数据副本之间进行数据同步的过程存在延时，这个延时不影响可用性。
+ 例如一次写操作只更新了一个结点就返回成功。那么其他节点和这个节点的数据时不一致的。
+ 此时的数据状态就是软状态。

***最终一致性（ Eventual Consistency）***
+ 指最终数据要实现一致性，例如：软状态的数据最终我们要通过一些手段将数据同步到其他数据节点上。
+ 弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。

**BASE与ACID**
+ 总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，
+ 它完全不同于ACID的强一致性模型，而是通过牺牲强一致性 来获得可用性。
+ 并允许数据在一段时间内是不一致的，但最终达到一致状态。
+ 但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的。
+ 因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。


#### 4、DTP分布式事务模型
+ 在分布式系统中，每一个机器节点虽然都能够明确的直到自己在进行事务操作中的结果时成功或失败，但却无法直接获取其他分布式节点的操作结果。
+ 因此，当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的ACID特性。就需要用到分布式事务。
+ DTP 全称 `Distributed Transaction Processing Reference`是X/Open这个组织定义出的一套分布式事务标准。
+ 主要包含以下角色：
    + *AP(Application Program)：* 也就是应用程序，可以理解为使用DTP的程序
    + *RM(Resource Manager)：* 资源管理器，一般是数据库，也可以是其他的资源管理器，如消息队列(如JMS数据源)，文件系统等
    + *TM(Transaction Manager)：* 事务管理器，管理全局事务，协调事务的提交或者回滚，并协调故障恢复。
+ 在该模型中，一个分布式事务（全局事务）可以被拆分成多个本地事务，运行在不同的AP和RM上，每个本地事务的ACID很好实现，但是全局事务必须保证每个事务要么都成功要么都失败


![](DTP.jpg)

**DTP的重要概念：**
+ ***事务：*** 一个事务是一个完整的工作单元，由多个独立的计算任务组成，这多个任务在逻辑上是原子的。
+ ***全局事务：*** 对于一次性操作多个资源管理器的事务，就是全局事务
+ ***分支事务：*** 在全局事务中，某一个资源管理器有自己独立的任务，这些任务的集合作为这个资源管理器的分支任务
+ ***控制线程：*** 用来表示一个工作线程，主要是关联AP,TM,RM三者的一个线程，也就是事务上下文环境。简单的说，就是需要标识一个全局事务以及分支事务的关系。

    
**XA规范：**
+ XA是DTP模型定义TM和RM之间通讯的接口规范。
+ TM用它来通知数据库事务的开始、结束、提交、回滚。基于XA规范衍生出下面的二阶段提交（2PC）、三阶段提交（3PC）。
+ `JTA(Java Transaction API)`仅定义了接口，它是XA协议的JAVA实现。
+ *其中JTA有几个重要的接口：*
    + `javax.transaction.TransactionManager:` 
        高层的事务管理器接口，供应用服务器使用,事务管理器承担着所有事务参与单元者的相互通讯的责任。
    + `javax.transaction.UserTransaction:` 
        高层的应用事务划分接口，供客户程序使用,给应用程序提供了编程控制事务边界的能力。如开启提交回滚事务
    + `javax.transaction.xa.XAResource:` 
        `X/Open XA`协议的标准Java映射，供事务性资源管理器使用。
    + `javax.transaction.Xid:` 
        Xid 接口是 X/Open 事务标识符XID结构的Java映射。此接口指定三个存取方法，以检索全局事务格式ID、全局事务ID和分支限定符。Xid 接口供事务管理器和资源管理器使用。此接口对应用程序不可见。

#### 5、2PC
+ `Two Phase Commit`,顾名思义，二阶段提交的意思。
+ 在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。
+ 当一个事务跨越多个节点时，为了保持事务的ACID特性，
+ 需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。
+ 因此，二阶段提交的算法思路可以概括为： 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。
+ 第一阶段(提交请求阶段) ； 第二阶段(提交执行阶段)。

##### 第一阶段(提交准备阶段)
+ 协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。
+ 参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。
+ 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个"同意"消息；如果参与者节点的事务操作实际执行失败，则它返回一个"中止"消息

***有时候，第一阶段也被称作投票阶段，即各参与者投票是否要继续接下来的提交操作。***

##### 第二阶段(提交执行阶段)
+ 第二阶段根据第一阶段会分为：成功或失败两种情况

***成功***
当协调者节点从所有参与者节点获得的响应消息都为"同意"时：
+ 协调者节点向所有参与者节点发出"正式提交"的请求。
+ 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
+ 参与者节点向协调者节点发送"完成"消息。
+ 协调者节点收到所有参与者节点反馈的"完成"消息后，完成事务。

***失败***
如果任一参与者节点在第一阶段返回的响应消息为"终止"，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：
+ 协调者节点向所有参与者节点发出"回滚操作"的请求。
+ 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。
+ 参与者节点向协调者节点发送"回滚完成"消息。
+ 协调者节点收到所有参与者节点反馈的"回滚完成"消息后，取消事务。

**缺点：**
+ ***同步阻塞：*** 事务执行过程中所有参与者都是阻塞型的，第三方参与者访问参与者占有的资源时会被阻塞；
+ ***单点故障：*** 协调者一旦发生故障，参与者会被阻塞。尤其在提交阶段，所有参与者都处于锁定资源状态中，无法完成事务操作；（可以选择新的协调者，但无法解决参与者被阻塞的问题）；
+ ***数据不一致：*** 提交阶段协调者向参与者发送commit信息，发生局部网络故障，会导致部分存在参与者未收到commit信息无法提交事务情况，导致出现数据不一致现象；


#### 6、3PC
+ `Three-phase commit`,顾名思义，三阶段提交的意思。
+ 三阶段提交是为解决两阶段提交协议的缺点而设计的。
+ 2PC中只有协调者有超时机制，在第二阶段事务提交时，协调者等待参与者反馈超时，会中断事务，因此被认为“保守”
+ 三阶段提交是“非阻塞”协议。三阶段提交是把二阶段的一阶段拆成了两个步骤先询问是否可以执行事务。
+ 这样三阶段提交就变成 `CanCommit`（发送预提交请求）、`PreCommit`(事务预提交)、`DoCommit`(事务提交) 三个阶段



**如下：**
+ 第一阶段：
    + 询问阶段，协调者向所有的参与者发送一个包含事务内容的CanCommit请求，参与者向协调者反馈事务询问的响应（超时终止）
+ 第二阶段：
    + 预提交阶段，
    + 在一阶段都通过后，协调者向所有的参与者发送preCommit请求，
    + 参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中
    + 各参与者向协调者反馈事务执行的响应，等待最终的指令（提交或中断），
+ 第三阶段：
    + 提交阶段，
    + 当二阶段都通过后，发起commit请求，如果有一个节点失败，则发送中止请求
    + 当发送commit请求时协调者宕机了，部分参与者没收到请求超时也是会提交的，会出现数据不一致（如果最终发送的是中止请求的话）

**3PC与2PC主要的不同：**
+ 3PC把2PC的一阶段分成两个阶段，CanCommit和PreCommit，然后加上超时机制
+ 3pc在协调者、参与者中都加入了超时判断机制，2pc只有协调者有。
+ 避免资源锁定太久导致浪费。但是3PC同样存在着很多问题。实现起来非常复杂，因为很难通过多次询问来解决系统间分歧问题，
+ 尤其是存在超时状态互不信任的分布式网络中，这也就是著名的拜占庭将军问题



### 二、Seata 是什么?
+ Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。
+ Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。
+ 本文只介绍简单的使用，不讲原理

#### 1、Seata术语
+ **TC (Transaction Coordinator) - 事务协调者**
维护全局和分支事务的状态，驱动全局事务提交或回滚。
相当于 `seata-server`
+ **TM (Transaction Manager) - 事务管理器**
定义全局事务的范围：开始全局事务、提交或回滚全局事务。
相当于我们开启全局事务的发起方 `@GlobalTransactional`
+ **RM (Resource Manager) - 资源管理器**
管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。
相当于我们的本地事务，：`@Transactional`

### 三、
